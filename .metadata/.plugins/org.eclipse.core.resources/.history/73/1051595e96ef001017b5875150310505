
#include "main.h"
#include <stdio.h> //printf. gets, fgets
#include <stdlib.h>
#include <string.h>

extern void delay_us(unsigned int us);

void dht11_output(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  GPIO_InitStruct.Pin = DHT11_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(DHT11_GPIO_Port, &GPIO_InitStruct);
}

void dht11_input(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  GPIO_InitStruct.Pin = DHT11_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(DHT11_GPIO_Port, &GPIO_InitStruct);
}

void dht11_main(void)
{
	enum state_t {OK, TIME_OUT, VALUE_ERROR, TRANS_ERROR};
	enum state_t state = OK;
	uint32_t us_counter = 0;

	int data[6] = {0};

	while(1)
	{
		for(int i=0; i<6; i++)
			data[i] = 0;
		state = OK;
		//======request signal======
		dht11_output();
		HAL_GPIO_WritePin(DHT11_GPIO_Port, DHT11_Pin, 0);
		HAL_Delay(20);

		HAL_GPIO_WritePin(DHT11_GPIO_Port, DHT11_Pin, 1);
		delay_us(30);
		dht11_input();

		us_counter = 0;
		while (HAL_GPIO_ReadPin(DHT11_GPIO_Port,DHT11_Pin)==1)
		{
			delay_us(2);
			us_counter += 2;
			if(us_counter > 50)
			{
				state = TIME_OUT;
				break;
			}
		}
		//---------- response start signal from DHT11-----
		if(state == OK)
		{
			us_counter = 0;
			while (HAL_GPIO_ReadPin(DHT11_GPIO_Port,DHT11_Pin)==0)
				{
					delay_us(2);
					us_counter += 2;
					if(us_counter > 100)
					{
						state = TIME_OUT;
						break;
					}
				}
		}

		if(state == OK)
		{
			us_counter = 0;
			while (HAL_GPIO_ReadPin(DHT11_GPIO_Port,DHT11_Pin)==1)
				{
					delay_us(2);
					us_counter += 2;
					if(us_counter > 100)
					{
						state = TIME_OUT;
						break;
					}
				}
		}

		//----data read port -----
		//---- data read port (총 40비트 = 5바이트 읽기) -----
		        if(state == OK)
		        {
		            // 5바이트를 순서대로 읽습니다. (습도상위, 습도하위, 온도상위, 온도하위, 체크섬)
		            for(int i = 0; i < 5; i++)
		            {
		                for(int j = 0; j < 8; j++) // 8비트 반복 (한 바이트 만들기)
		                {
		                    // [1단계] 50us 동안의 Low 신호 지나가기 (비트 시작 알림)
		                    // Low인 동안은 그냥 기다립니다.
		                    us_counter = 0;
		                    while (HAL_GPIO_ReadPin(DHT11_GPIO_Port, DHT11_Pin) == 0)
		                    {
		                        delay_us(1);
		                        us_counter++;
		                        if(us_counter > 100) { state = TIME_OUT; break; }
		                    }

		                    // [2단계] High 신호가 얼마나 유지되는지 시간 재기
		                    // 이게 짧으면(26~28us) '0', 길면(70us) '1' 입니다.
		                    us_counter = 0;
		                    while (HAL_GPIO_ReadPin(DHT11_GPIO_Port, DHT11_Pin) == 1)
		                    {
		                        delay_us(1);
		                        us_counter++;
		                        if(us_counter > 100) { state = TIME_OUT; break; }
		                    }

		                    // [3단계] 0인지 1인지 판별해서 저장하기
		                    // (1) 일단 기존 데이터를 왼쪽으로 한 칸 밉니다. (빈칸 만들기)
		                    data[i] = data[i] << 1;

		                    // (2) 만약 High 시간이 45us보다 길었다면 '1'이므로 1을 더해줍니다.
		                    if(us_counter > 45)
		                    {
		                        data[i] = data[i] | 1;
		                    }
		                    // 짧았다면 '0'인데, 위에서 밀기만 했으므로 자동으로 끝자리는 0이 됩니다.
		                }
		            }
		        }

		        // 결과 출력하기 (체크섬 확인)
		        if(state == OK)
		        {
		            // 5번째 바이트(체크섬)가 앞의 4개 합과 같은지 확인
		            uint8_t check_sum = data[0] + data[1] + data[2] + data[3];

		            if(data[4] == check_sum)
		            {
		                printf("Humidity: %d.%d %% | Temp: %d.%d C\r\n", data[0], data[1], data[2], data[3]);
		            }
		            else
		            {
		                printf("Error: Checksum mismatch!\r\n");
		            }
		        }
		        else
		        {
		            printf("Error: Sensor Time out\r\n");
		        }

		HAL_Delay(2000); // 안정화 시간

}
}
